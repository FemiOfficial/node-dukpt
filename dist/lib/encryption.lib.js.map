{"version":3,"sources":["../../lib/encryption.lib.js"],"names":["crypto","require","Encryption","hexKey","hexData","aesMode","keyBuf","length","Error","dataBuf","Buffer","from","iv","cipher","createCipheriv","setAutoPadding","encrypted","update","final","toString","encryptedHexData","createDecipheriv","decrypted","module","exports"],"mappings":";;;;;;AAAA,IAAMA,SAASC,QAAQ,QAAR,CAAf;;IAEMC,U;;;;;;;mCAEgBC,M,EAAQC,O,EAASC,O,EAAS;;AAExCA,sBAAUA,WAAW,aAArB;;AAEA,gBAAMC,SAASH,MAAf;;AAEA,gBAAIG,OAAOC,MAAP,IAAiB,EAArB,EAAyB;AACrB,sBAAM,IAAIC,KAAJ,CAAU,mDAAV,CAAN;AACH;;AAED,gBAAMC,UAAUC,OAAOC,IAAP,CAAYP,OAAZ,EAAqB,KAArB,CAAhB;AACA,gBAAMQ,KAAKF,OAAOC,IAAP,CAAY,kCAAZ,EAAgD,KAAhD,CAAX;;AAEA,gBAAME,SAASb,OAAOc,cAAP,CAAsBT,OAAtB,EAA+BC,MAA/B,EAAuCM,EAAvC,EAA2CG,cAA3C,CAA0D,IAA1D,CAAf;AACA,gBAAIC,YAAYH,OAAOI,MAAP,CAAcR,OAAd,CAAhB;AACAO,yBAAaH,OAAOK,KAAP,CAAa,QAAb,CAAb;;AAEA,mBAAOR,OAAOC,IAAP,CAAYK,SAAZ,EAAuB,QAAvB,EAAiCG,QAAjC,CAA0C,KAA1C,CAAP;AACH;;;mCAEiBhB,M,EAAQiB,gB,EAAkBf,O,EAAS;;AAEjDA,sBAAUA,WAAW,aAArB;;AAEA,gBAAMC,SAASH,MAAf;;AAEA,gBAAIG,OAAOC,MAAP,IAAiB,EAArB,EAAyB;AACrB,sBAAM,IAAIC,KAAJ,CAAU,mDAAV,CAAN;AACH;;AAED,gBAAMC,UAAUC,OAAOC,IAAP,CAAYS,gBAAZ,EAA8B,KAA9B,CAAhB;AACA,gBAAMR,KAAKF,OAAOC,IAAP,CAAY,kCAAZ,EAAgD,KAAhD,CAAX;;AAEA,gBAAME,SAASb,OAAOqB,gBAAP,CAAwBhB,OAAxB,EAAiCC,MAAjC,EAAyCM,EAAzC,CAAf;AACA,gBAAIU,YAAYT,OAAOI,MAAP,CAAcR,OAAd,CAAhB;AACAa,yBAAaT,OAAOK,KAAP,EAAb;;AAEA,mBAAOR,OAAOC,IAAP,CAAYW,SAAZ,EAAuB,OAAvB,EAAgCH,QAAhC,CAAyC,KAAzC,CAAP;AAEH;;;;;;AAGLI,OAAOC,OAAP,GAAiBtB,UAAjB","file":"encryption.lib.js","sourcesContent":["const crypto = require('crypto');\n\nclass Encryption {\n\n    static encryptAES(hexKey, hexData, aesMode) {\n\n        aesMode = aesMode || 'aes-256-cbc';\n\n        const keyBuf = hexKey;\n\n        if (keyBuf.length != 32) {\n            throw new Error('key for aes encryption must be 32 bytes in length');\n        }\n\n        const dataBuf = Buffer.from(hexData, 'hex');\n        const iv = Buffer.from('00000000000000000000000000000000', 'hex');\n\n        const cipher = crypto.createCipheriv(aesMode, keyBuf, iv).setAutoPadding(true);\n        let encrypted = cipher.update(dataBuf);\n        encrypted += cipher.final('binary');\n\n        return Buffer.from(encrypted, 'binary').toString('hex');\n    }\n\n    static decryptAES(hexKey, encryptedHexData, aesMode) {\n\n        aesMode = aesMode || 'aes-256-cbc';\n\n        const keyBuf = hexKey;\n\n        if (keyBuf.length != 32) {\n            throw new Error('key for AES encryption must be 32 bytes in length');\n        }\n\n        const dataBuf = Buffer.from(encryptedHexData, 'hex');\n        const iv = Buffer.from('00000000000000000000000000000000', 'hex');\n\n        const cipher = crypto.createDecipheriv(aesMode, keyBuf, iv);\n        let decrypted = cipher.update(dataBuf);\n        decrypted += cipher.final();\n\n        return Buffer.from(decrypted, 'ascii').toString('hex');\n\n    }\n}\n\nmodule.exports = Encryption;"]}