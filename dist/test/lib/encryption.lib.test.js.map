{"version":3,"sources":["../../../test/lib/encryption.lib.test.js"],"names":["RandExp","require","Encryption","crypto","should","generateRandomString","gen","describe","it","done","randomString","key","createHash","update","digest","encrypted","encryptAES","Buffer","from","toString","test","be","true","err","exist","decrypted","decryptAES","equal","decryptKey","message"],"mappings":"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","file":"encryption.lib.test.js","sourcesContent":["const RandExp = require('randexp');\nconst Encryption = require('../../lib/encryption.lib');\nconst crypto = require('crypto');\nconst should = require('should');\n\nfunction generateRandomString() {\n    return new RandExp(/[a-zA-Z0-9]{10,20}/).gen();\n}\n\ndescribe('aes encryption test suite', () => {\n    it('should encrypt a string properly and should output a hex encoded string', (done) => {\n        const randomString = generateRandomString();\n        const key = crypto.createHash('sha256').update(randomString).digest();\n        const encrypted = Encryption.encryptAES(key,Buffer.from(randomString, 'ascii').toString('hex'));\n        (/^[a-fA-F0-9]+$/).test(encrypted).should.be.true();\n        done();\n    });\n\n    it('should throw an error when a key with an incorrect length is provided for encryption', (done) => {\n        const randomString = generateRandomString();\n        const key = crypto.createHash('sha512').update(randomString).digest();\n        try{\n            Encryption.encryptAES(key,Buffer.from(randomString, 'ascii').toString('hex'));\n        }\n        catch(err){\n            should.exist(err);\n        }\n\n        done();\n    })\n});\n\ndescribe('3des encryption test suite', () => {\n    it('should decrypt properly when encrypted string is provided', (done) => {\n        const randomString = generateRandomString();\n        const key = crypto.createHash('sha256').update(randomString).digest();\n        const encrypted = Encryption.encryptAES(key,Buffer.from(randomString, 'ascii').toString('hex'));\n        const decrypted = Encryption.decryptAES(key, encrypted);\n        (/^[a-fA-F0-9]+$/).test(decrypted).should.be.true();\n        Buffer.from(decrypted, 'hex').toString('ascii').should.equal(randomString);\n        done();\n    });\n\n    it('should throw an error when a key with incorrect length is provided for decryption', (done) => {\n        const randomString = generateRandomString();\n        const key = crypto.createHash('sha256').update(randomString).digest();\n        const decryptKey = crypto.createHash('sha512').update(randomString).digest();\n        const encrypted = Encryption.encryptAES(key,Buffer.from(randomString, 'ascii').toString('hex'));\n        try{\n            const decrypted = Encryption.decryptAES(decryptKey, encrypted);\n        }\n        catch(err){\n            should.exist(err);\n            err.message.should.equal('key for AES encryption must be 32 bytes in length');\n        }\n        done();\n    });\n});"]}