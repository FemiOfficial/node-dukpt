{"version":3,"sources":["../../../test/lib/dukpt.lib.test.js"],"names":["should","require","Dukpt","RandExp","sinon","dukpt","bdk","ksn","cc_trackdata_example","cc_trackdata_hex_example","cc_trackdata_encrypted_sample","getRandomText","gen","getRandomHexText","Buffer","from","toString","describe","beforeEach","it","done","encrypted","dukptEncrypt","inputEncoding","equal","err","exist","message","dukptDecrypt","outputEncoding","toLowerCase","maskedKSN","_getMaskedKSN","toUpperCase","stub","dukptSessKey","generateDukptSessionKey","restore"],"mappings":"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","file":"dukpt.lib.test.js","sourcesContent":["const should = require('should');\nconst Dukpt = require('../../index');\nconst RandExp = require('randexp');\nconst sinon = require('sinon');\n\nlet dukpt = null;\nlet bdk = '0123456789ABCDEFFEDCBA9876543210';\nlet ksn = 'FFFFFFFFFFFFFFFFFFFF';\nlet cc_trackdata_example = '%B4815881002861896^YATES/EUGENE JOHN              ^37829821000123456789?'; // taken from wikipedia. not an actual card\nlet cc_trackdata_hex_example = '2542343831353838313030323836313839365e59415445532f455547454e45204a4f484e20202020202020202020202020205e33373832393832313030303132333435363738393f';\nlet cc_trackdata_encrypted_sample = '88B0208C24474EB41EE216D3BD0D226777FBBE15CEB7A2F840F16588FA583100848D334DD1B33CCD03728AD03E65993BB82F969EC4C5A68A83B8C5D80CC899D0E5C184D5BA48E7FF';\n\nfunction getRandomText() {\n    return new RandExp(/[A-Z0-9]{50}/).gen();\n}\n\nfunction getRandomHexText() {\n    return Buffer.from(getRandomText(), 'ascii').toString('hex');\n}\n\ndescribe('dukpt encryption tests with hex output encoding', () => {\n\n    beforeEach(()=> {\n        dukpt = new Dukpt(bdk, ksn);\n    });\n\n    it('should generate correct encrypted output when input encoding type : ascii', (done) => {\n        let encrypted = dukpt.dukptEncrypt(cc_trackdata_example, {\n            inputEncoding: 'ascii'\n        });\n\n        encrypted.should.equal(cc_trackdata_encrypted_sample);\n        done();\n    });\n\n    it('should generate correct encrypted output when input encoding type : hex', (done) => {\n        let encrypted = dukpt.dukptEncrypt(cc_trackdata_hex_example, {\n            inputEncoding: 'hex'\n        });\n\n        encrypted.should.equal(cc_trackdata_encrypted_sample);\n        done();\n    });\n\n    it('should throw an error when unknown input encoding provided', (done) => {\n        try {\n            dukpt.dukptEncrypt(cc_trackdata_hex_example, {\n                inputEncoding: 'unknown'\n            });\n        }\n        catch(err){\n            should.exist(err);\n            err.message.should.equal('unsupported input encoding type for dukpt encrypt : \\'unknown\\'');\n        }\n        done();\n    });\n\n    it('should throw an error when input string is not provided', (done) => {\n        try{\n            dukpt.dukptEncrypt(false, {\n                inputEncoding: 'hex'\n            });\n        }\n        catch(err){\n            should.exist(err);\n            err.message.should.equal('either session key or data not provided');\n        }\n        done();\n    });\n});\n\ndescribe('dukpt decryption tests with hex input encoding', () => {\n\n    beforeEach(()=> {\n        dukpt = new Dukpt(bdk, ksn);\n    });\n\n    it('should generate correct decrypted output when output encoding type : ascii', (done) => {\n        let encrypted = dukpt.dukptDecrypt(cc_trackdata_encrypted_sample, {\n            outputEncoding: 'ascii'\n        });\n\n        encrypted.should.equal(cc_trackdata_example);\n        done();\n    });\n\n    it('should generate correct decrypted output when output encoding type : hex', (done) => {\n        let encrypted = dukpt.dukptDecrypt(cc_trackdata_encrypted_sample, {\n            outputEncoding: 'hex'\n        });\n\n        encrypted.toLowerCase().should.equal(cc_trackdata_hex_example);\n        done();\n    });\n\n    it('should throw an error when unknown output encoding provided', (done) => {\n        try {\n            dukpt.dukptDecrypt(cc_trackdata_encrypted_sample, {\n                outputEncoding: 'unknown'\n            });\n        }\n        catch(err){\n            should.exist(err);\n            err.message.should.equal('unsupported output encoding for dukpt decrypt');\n        }\n        done();\n    });\n\n    it('should throw an error when input encrypted string is not provided', (done) => {\n        try{\n            dukpt.dukptDecrypt(false, {\n                outputEncoding: 'ascii'\n            });\n        }\n        catch(err){\n            should.exist(err);\n            err.message.should.equal('either session key or data not provided');\n        }\n        done();\n    });\n});\n\ndescribe('private methods test suite', () => {\n    it('should return same value when ksn \"0000FFFFFFFFFFE00000\" is masked with _getMaskedKSN', (done) => {\n        const ksn = '0000FFFFFFFFFFE00000';\n        const maskedKSN = dukpt._getMaskedKSN(ksn);\n        (Buffer.from(maskedKSN, 'ascii').toString('hex').toUpperCase()).should.equal(ksn);\n        done();\n    });\n\n    it('should generate dukpt session key provided ipek and ksn', (done) => {\n        const stub = sinon.stub(dukpt, '_createDataKeyHex', () => '123');\n\n        const dukptSessKey = dukpt.generateDukptSessionKey(getRandomHexText(), getRandomHexText());\n\n        dukptSessKey.should.equal('123');\n        stub.restore();\n        done();\n    });\n\n    it('should throw an error when either ipek or ksn is not provided for generateDukptSessionKey', (done) => {\n        const stub = sinon.stub(dukpt, '_createDataKeyHex', () => '123' );\n        try{\n            dukpt.generateDukptSessionKey('', getRandomHexText());\n        }\n        catch (err){\n            should.exist(err);\n            err.message.should.equal('either IPEK or data params not provided');\n        }\n\n        try{\n            dukpt.generateDukptSessionKey(getRandomHexText(), '');\n        }\n        catch (err){\n            should.exist(err);\n            err.message.should.equal('either IPEK or data params not provided');\n        }\n        stub.restore();\n        done();\n    });\n});\n\n\n"]}